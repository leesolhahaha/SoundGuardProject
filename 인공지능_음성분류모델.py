# -*- coding: utf-8 -*-
"""음성분류모델.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BxvD4Y8KGz8iEaiGWJq9vYOPbkRXC6ni
"""

# 필요한 패키지 설치
!pip install pydub
!pip install torch
!pip install librosa
!pip install konlpy
!pip install git+https://github.com/openai/whisper.git
!pip install ffmpeg-python

# 필요한 라이브러리 및 모듈 import
import argparse
import os
import boto3
import subprocess
from pydub import AudioSegment
import torch
import whisper
import numpy as np
import librosa
from konlpy.tag import Komoran
import time

# ffmpeg 설치 (conda를 사용)
!conda install -y ffmpeg -c conda-forge

# S3에서 데이터 다운로드 및 처리를 위한 함수 정의
def download_data(s3_path, local_path, last_modified):
    s3 = boto3.resource('s3')
    bucket_name = 'chuldongedact'
    file_name = os.path.basename(s3_path)
    local_file_path = os.path.join(local_path, file_name)

    # 로컬 폴더가 없으면 생성
    os.makedirs(local_path, exist_ok=True)

    try:
        # S3 객체의 최종 수정 시간 가져오기
        s3_object = s3.Object(bucket_name, file_name)
        s3_last_modified = s3_object.last_modified

        # 파일이 업데이트되었거나 파일이 없는 경우 다운로드
        if s3_last_modified != last_modified:
            print(f"업데이트된 파일 다운로드 중: {file_name}")
            s3.Bucket(bucket_name).download_file(file_name, local_file_path)

            # 최종 수정 시간 업데이트
            last_modified = s3_last_modified

        return local_file_path, last_modified
    except Exception as e:
        print(f"{file_name} 파일을 S3에서 찾을 수 없습니다. 파일을 기다리는 중입니다...")
        return None, last_modified  # 파일이 없는 경우 None 반환

# 메인 함수 정의
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--s3_data_path', type=str, default='s3://chuldongedact/record.wav')
    parser.add_argument('--local_data_path', type=str, default='opt/ml/processing/output/data/')
    args, _ = parser.parse_known_args()

    last_modified = None

    while True:
        # S3 버킷에서 파일이 존재하는지 확인
        if s3_file_exists(args.s3_data_path):
            # S3에서 로컬로 데이터 다운로드
            local_file_path, last_modified = download_data(args.s3_data_path, args.local_data_path, last_modified)

            if local_file_path:
                # 로컬 경로를 사용하여 오디오 파일 로드
                input_audio_path = os.path.join(args.local_data_path, 'record.wav')

        # Pydub을 사용하여 오디오 파일 로드 및 처리
        audio = AudioSegment.from_file(input_audio_path)
        x = np.array(audio.get_array_of_samples())
        sr = audio.frame_rate

        # Whisper 모델 로드
        model = whisper.load_model("small")

        # 오디오 로드 및 30초에 맞게 패딩 또는 잘라내기
        audio_raw = whisper.load_audio(input_audio_path)
        audio = whisper.pad_or_trim(audio_raw)

        # 로그 멜 스펙트로그램 생성 및 모델과 동일한 장치로 이동
        melspectrogram = whisper.log_mel_spectrogram(audio).to(model.device)

        # ASR 실행
        options = whisper.DecodingOptions(fp16=False)
        result = whisper.decode(model, melspectrogram, options)

        # 인식된 텍스트 출력
        print(result.text)

        # 위험 문장 리스트 생성
        target_sentences = ["119에 신고해줘", "112에 신고해", "살려주세요", "내 몸 만지지 마", "경찰불러주세요", "구조해주세요", "도와줘", "절도범이야",
                            "도와주세요", "때리지마", "도둑이야", "도난 당했어", "구출해줘", "어디만져", "구해주세요", "구해줘", "절도당했어", "구출해줘", "손대지마"]

        # 실제 음성 인식에서 얻은 텍스트로 채워야 하는 부분
        recognized_text = result.text

        # Komoran 형태소 분석기 초기화
        komoran = Komoran()

        # 설정한 문장들을 순회하며 명사와 동사 추출
        target_words = set()  # 중복을 허용하지 않는 집합으로 변경
        for target_sentence in target_sentences:
            target_words.update(komoran.nouns(target_sentence))
            target_words.update([word for word, pos in komoran.pos(target_sentence) if pos.startswith('V')])

        # 음성 인식된 문장을 형태소 분석하여 명사와 동사 추출
        recognized_words = set()  # 중복을 허용하지 않는 집합으로 변경
        recognized_words.update(komoran.nouns(recognized_text))
        recognized_words.update([word for word, pos in komoran.pos(recognized_text) if pos.startswith('V')])

        # 삭제할 명사와 동사를 지정
        words_to_remove = {"부르", "말", "주", "몸"}

        # 추가할 명사와 동사를 지정
        words_to_add = {"119", "112"}

        # 설정한 문장에서 삭제할 명사와 동사 제거
        for word in words_to_remove:
            if word in target_words:
                target_words.remove(word)

        # 설정한 문장에 추가할 명사와 동사 추가
        target_words.update(words_to_add)

        # 모든 설정한 문장의 명사와 동사가 음성 인식된 문장에 포함되는지 확인
        danger_detected = any(word in recognized_words for word in target_words)

        if danger_detected:
            print("위험 감지")
        else:
            print("이상 없음")

        # 결과를 기록할 디렉토리 생성
        output_directory = "opt/ml/output/"
        os.makedirs(output_directory, exist_ok=True)

        # 결과를 S3에 업로드
        s3_result_path = 's3://chuldongedact/processing/results/result.txt'  # 변경 필요
        output_file_path = os.path.join(output_directory, "result.txt")

        # 기존 파일이 있으면 삭제
        if os.path.exists(output_file_path):
            os.remove(output_file_path)

        with open(output_file_path, "w") as result_file:
            result_file.write(result.text + "\n" + str(danger_detected))

        s3 = boto3.resource('s3')
        s3.Bucket('chuldongedact').upload_file(output_file_path, s3_result_path)

        # 다운로드한 오디오 파일 삭제
        os.remove(input_audio_path)

        # 10초 동안 대기 후 다시 확인
        time.sleep(10)

# S3 파일 존재 여부 확인 함수
def s3_file_exists(s3_path):
    s3 = boto3.client('s3')
    bucket_name = 'chuldongedact'
    file_name = os.path.basename(s3_path)

    try:
        # head_object 시도, 실패하면 파일이 존재하지 않음
        s3.head_object(Bucket=bucket_name, Key=file_name)
        return True
    except ClientError:
        return False

if __name__ == '__main__':
    main()